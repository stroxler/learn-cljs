* Notes on this tutorial (which covers 06, 07, 08, and 10 but not 09)
** multi-page webapps in cljs, alternate

*** how the previous tutorial worked
There's a setion in the previous tutorial's README about
it's approach to multi-page webapps, the key thing is that
each cljs file corresponded to a page, and exported its
init function.

I prefer to have my entry-points more tightly organized,
so in this tutorial I return to the single-page app
norm of using only core.cljs for init, and I expose
a separate init function for each page

Note that the =main.cljs.edn= file now once again looks
the way it did before, and it doesn't have to change if we
add or remove pages.

*** lessons learned in that refactor

Initially I copy-paseted =login.cljs= to get the new =core.cljs=,
and this lead to =core.clj= having namespace =login= at first.
This caused all sorts of problems involving the browser state
involving out-of-date namespace definitions; in this situation
my advice is to shut down your development environment, make
clean, reload the browser (to get a page not found), and
restart everything. Do it with devtools open on the browser - the
idea is that you need to clear your cache completely, or else you
can get aliasing... TBH I still don't fully understand what the
issue was, but reloading everything eventually worked.

Fortunately this kind of refactor is relatively rare, hopefully
in time I'll have a better mental model for the compile / send
to browser cycle.

** add a clojure webserver

*** getting a minimal server running
The changes needed: in =build.boot=, and "src/clj" as a =source-path=,
and =compojure= as a dependency. Then modify the =serve= action.

In the server, all you need at a minimum is a =defroutes= statement.
Frequently for real examples people wind up using a =->= statement to
wrap the handler with various things (a =shoreleave= handler, or some
=hiccup= middleware, or other things like that) but for a dead-simple
example this is not needed.

I won't dwell on the clojure code much since this isn't a clojure tutorial
(and in fact I'm intentionally diverging from the authors on the question
of how we do ajax calls because I don't want to use any libraries that would
tie me to clojure webservers)

*** Adding a json API

At this point I diverged from the tutorial because while I start out with
clojure, I want to stick to making and using APIs in a non-clojure-specific
way, that is, via vanilla json ajax.

I did the server side first, and it actually turned out to be pretty
time-consuming for me to figure out a basic json POST on my own, I definitely
want to sit down with a book on the subject before I have to do much more -
ring and compojure seem to be well-put together, but they aren't guessable
for me.

Also there's something wrong with my =build.boot= file; I thought the
=serve= task with =:reload true= was supposed to reload the server side,
but my clojure code wasn't getting reloaded. I probably won't fix that in
this tutorial since I'm more concerned about clojurescript, but the solution
is something to look out for, because that made debugging really obnoxious.

I added a curl script so that you can verify this is a normal json api,
not relying on any clojure-specific magic like a lot of the =sente= and
=shoreleave= demos I've seen - you can replace this server with python or
another backend without changing any of the clojurescript code.

The client-side I handle with =cljs-ajax=, which is a pretty vanilla
ajax library that can handle several data formats including json. This
particular library is supposed to be portable to clojure, which makes
it potentially useful on the server-side as well (although I think as
it stands you can't use it for server-side clojurescript on node - when
you do use clojurescript I think it assumes you're in a browser)
